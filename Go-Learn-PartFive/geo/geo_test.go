// По конвенции файл с тестированием нужно называть также как файл с функционалом + _test.go
// Располагаться файл должен непосредственно в директории с тестируемым файлом

// Пакет с тестами можно назвать также как и пакет, в директории которого он лежит и тогда это будет white box тестирование
// То есть доступ будет ко всему функционалу, который даже не экспортируется, потому что это один и тот же пакет

// Если назвать пакет с тестами _test, то это black box тестирование, потому что доступ будет только к тому функционалу, который экспортируется
package geo_test

import (
	"Go-learn-part-five/geo"
	"testing"
)

// Функции для тестирования записываются всегда Test + название проверяемой функции
// В аргументы принимает t *testing.T
func TestGetMyLocation(t *testing.T) {
	// Каждый тест должен иметь структуру состоящую из следующих блоков:
	// Arrange - подготовка тестирования (прописываем ожидаемый результат и заполняем данные для функции)

	city := "London" // Записываю, что будет передано в функцию
	expectedResult := geo.GeoData{
		City: "London",
	} // Записываю, что ожидаю к возврату после выполнения функции

	// Act - выполнение функции

	got, err := geo.GetMyLocation(city) // Выполняю функцию и передаю значение, которое хочу проверить

	// Assert - проверка результата из act с тем, что прописано в arrange

	if err != nil { // Проверяю, что если функция выпала с ошибкой, то не был получен город
		t.Error(err)
	}
	if got.City != expectedResult.City { // Проверяю, что если город, который получился в результате функции не совпадает с тем, что ожидалось, то выпадает ошибка
		t.Errorf("Ожидалось %v, получено %v", expectedResult, got)
	}

}

// Теперь напишу негативный тест для проверки вывода ошибки о несуществующем городе
func TestGetMyLocationNoCity(t *testing.T) {
	// Arrange
	city := "Londownsad" // Создаю перменную с намеренной ошибой

	// Act
	_, err := geo.GetMyLocation(city)

	// Assert
	if err != geo.ErrorNoCity {
		t.Errorf("Ожидалось %v, получено %v", geo.ErrorNoCity, err)
	}

}
