package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {

	// runtime - это встроенная библиотека в Go, которая позволяет управлять потоками
	// fmt.Println(runtime.NumCPU()) // Здесь выводится количество одновременных выполнений горутин, которое поддерживает компьютер. То есть невозможно выполнять горутин больше этого числа на данном компьютере чисто физически
	// runtime.GOMAXPROCS(2)         // Так задается вручную, сколько одновременно горутин можно выполнять. Если поставить число больше количества ядер на компьютере, то все равно будет выполняться максимально возможное количество

	// go printInt(10) // Таким образом создается горутина. Горутина - это легковесный поток (горутина ~2Кб, а обычный поток ~1Мб)
	// Горутины могут работать как конкурентно, так и параллельно
	// Отличие горутин от потоков также в том, что ими управляет планировщик Go, а не планировщик ОС
	// Треды переключается автоматически под капотом Go
	// При такой записи будет выводиться сразу Exit..., потому что как только завершается главная горутина main, мы выходим из программы и созданная вручную горутина даже не успевает отработать

	// runtime.Gosched() // Этот метод позволяет вручную переключиться между горутинами
	// Теперь функция выполнится полностью, а после завершения вернется в главную горутину и завершит ее выполнение
	// time.Sleep(time.Second) Также например можно так сказать планирощику Go перейти к другому потоку, потому что он поймет, что можно выполнять дргуую горутину пока в этой действует sleep
	// fmt.Println("Exit...")

	// withWait()

	writeWithMutex()
}

// func printInt(n int) {
// 	for i := 0; i < n; i++ {
// 		fmt.Println(i)
// 	}
// }

// func withWait() {
// 	var wg sync.WaitGroup // Так создается wait группа, она нужна для того, чтобы синхронизировать горутины

// 	for i := 0; i <= 10; i++ {
// 		wg.Add(1) // Метод Add позволяет добавить таску в счетчик wait группы

// 		go func(i int) {
// 			fmt.Println(i)
// 			wg.Done() // Этот метод говорит wait групе, что это таска выполнена и можно убирать ее из счетчика
// 		}(i)
// 	}

// 	wg.Wait() // Этот метод говорит, что основная горутина не должна быть завершена пока в wait группе еще есть горутины для выполнения
// 	fmt.Println("Exit...")
// }

func writeWithMutex() {
	start := time.Now()
	var wg sync.WaitGroup
	var mu sync.Mutex // Так создается Mutex. Он дает возможность предоставить эксклюзивные права к какому-либо участку кода только одной горутине
	var counter int

	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			time.Sleep(time.Nanosecond)

			mu.Lock() // Так локается участок кода. Остальные горутины пока не могут получить доступ к этому участку висят в ожидании
			counter++
			mu.Unlock() // Так анлокается участок кода и доступ к нему получает опять только одна горутина
		}()
	}
	wg.Wait()
	fmt.Println(counter)
	fmt.Println(time.Now().Sub(start).Seconds())
}
